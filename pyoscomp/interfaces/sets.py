# pyoscomp/interfaces/sets.py

"""
OSeMOSYS Set definitions for the ScenarioData interface.

This module defines the OSeMOSYSSets dataclass that holds all 11 OSeMOSYS sets
as immutable frozensets for type safety and efficient membership testing.
"""

from dataclasses import dataclass
from typing import List, Set, FrozenSet, Union

# Type alias for set contents
SetType = FrozenSet[str]
YearSetType = FrozenSet[int]


@dataclass(frozen=True)
class OSeMOSYSSets:
    """
    Immutable container for all OSeMOSYS set definitions.
    
    Sets define the index spaces for parameters. All sets are stored
    as immutable frozensets for type safety and efficient membership testing.
    
    Attributes
    ----------
    regions : frozenset[str]
        REGION set - spatial nodes/regions in the model.
    years : frozenset[int]
        YEAR set - model time horizon years.
    technologies : frozenset[str]
        TECHNOLOGY set - conversion technologies.
    fuels : frozenset[str]
        FUEL set - energy carriers (auto-generated from activity ratios).
    emissions : frozenset[str]
        EMISSION set - pollutant types (optional, empty if unused).
    modes : frozenset[str]
        MODE_OF_OPERATION set - technology operating modes.
    timeslices : frozenset[str]
        TIMESLICE set - temporal subdivisions (Season × DayType × DailyTimeBracket).
    seasons : frozenset[str]
        SEASON set - seasonal subdivisions of the year.
    daytypes : frozenset[str]
        DAYTYPE set - day classifications (e.g., weekday, weekend).
    dailytimebrackets : frozenset[str]
        DAILYTIMEBRACKET set - intra-day time brackets.
    storages : frozenset[str]
        STORAGE set - storage facilities (optional, empty if unused).
    
    Notes
    -----
    - FUEL and MODE_OF_OPERATION are typically auto-generated by SupplyComponent
    - EMISSION and STORAGE are optional (empty frozenset if not used)
    - All sets use `VALUE` column in CSV files per OSeMOSYS convention
    
    Examples
    --------
    >>> sets = OSeMOSYSSets(
    ...     regions=frozenset(['REGION1']),
    ...     years=frozenset([2025, 2030]),
    ...     technologies=frozenset(['COAL_PP', 'SOLAR_PV']),
    ...     fuels=frozenset(['COAL', 'ELEC']),
    ...     emissions=frozenset(),
    ...     modes=frozenset(['MODE1']),
    ...     timeslices=frozenset(['S1_D1_B1']),
    ...     seasons=frozenset(['S1']),
    ...     daytypes=frozenset(['D1']),
    ...     dailytimebrackets=frozenset(['B1']),
    ...     storages=frozenset()
    ... )
    >>> sets.validate_non_empty(['regions', 'years'])
    """
    regions: SetType
    years: YearSetType
    technologies: SetType
    fuels: SetType
    emissions: SetType
    modes: SetType
    timeslices: SetType
    seasons: SetType
    daytypes: SetType
    dailytimebrackets: SetType
    storages: SetType
    
    # Required sets (must be non-empty for valid scenario)
    REQUIRED_SETS = ['regions', 'years', 'technologies', 'timeslices']
    
    # Optional sets (can be empty)
    OPTIONAL_SETS = ['emissions', 'storages']
    
    # Mapping from attribute name to CSV filename
    @staticmethod
    def csv_filename(attr_name: str) -> str:
        """Return CSV filename for a set attribute."""
        mapping = {
            'regions': 'REGION.csv',
            'years': 'YEAR.csv',
            'technologies': 'TECHNOLOGY.csv',
            'fuels': 'FUEL.csv',
            'emissions': 'EMISSION.csv',
            'modes': 'MODE_OF_OPERATION.csv',
            'timeslices': 'TIMESLICE.csv',
            'seasons': 'SEASON.csv',
            'daytypes': 'DAYTYPE.csv',
            'dailytimebrackets': 'DAILYTIMEBRACKET.csv',
            'storages': 'STORAGE.csv',
        }
        return mapping.get(attr_name, f"{attr_name.upper()}.csv")
    
    def validate_non_empty(self, required_sets: List[str] = None) -> None:
        """
        Validate that specified sets are non-empty.
        
        Parameters
        ----------
        required_sets : List[str], optional
            List of set attribute names to check. If None, uses REQUIRED_SETS.
        
        Raises
        ------
        ValueError
            If any required set is empty.
        """
        if required_sets is None:
            required_sets = self.REQUIRED_SETS
        
        for set_name in required_sets:
            value = getattr(self, set_name, None)
            if value is None:
                raise ValueError(f"Set '{set_name}' does not exist")
            if not value:
                raise ValueError(f"Required set '{set_name}' is empty")
    
    def validate_membership(
        self, 
        values: Union[Set[str], List[str], FrozenSet[str]], 
        set_name: str, 
        context: str = ""
    ) -> None:
        """
        Validate that all values exist in the specified set.
        
        Parameters
        ----------
        values : set, list, or frozenset
            Values to check for membership.
        set_name : str
            Name of the set attribute to check against.
        context : str, optional
            Context string for error message (e.g., "in CapitalCost.csv").
        
        Raises
        ------
        ValueError
            If any value is not in the set.
        """
        reference_set = getattr(self, set_name)
        missing = set(values) - reference_set
        if missing:
            ctx = f" {context}" if context else ""
            raise ValueError(
                f"Invalid {set_name}{ctx}: {sorted(missing)} not in set"
            )
    
    def get_sorted_years(self) -> List[int]:
        """Return years as a sorted list for iteration."""
        return sorted(self.years)
    
    def get_sorted_timeslices(self) -> List[str]:
        """Return timeslices as a sorted list for iteration."""
        return sorted(self.timeslices)
    
    def __contains__(self, item: tuple) -> bool:
        """
        Check if (set_name, value) pair exists.
        
        Examples
        --------
        >>> ('regions', 'REGION1') in sets
        True
        """
        set_name, value = item
        return value in getattr(self, set_name, frozenset())
            